# Const

## 1. 基本概念
`const` 关键字主要用于限定数据**不可修改**。  
凡是被申明为 `const` 的数据在初始化之后，都是不被允许被修改的。

使用 `const` 的优缺点如下：  
+ 优点
  + 增强程序的安全性、稳定性和多线程环境下的可靠性；
  + 提供类型检查，使得代码更加严谨，帮助编译器优化程序。
+ 缺点
  + 过度或不当使用 const 可能降低程序的灵活性，使得某些操作变得笨重或难以修改。

## 2. `const` 修饰变量、指针和引用
### 2.1 修饰普通变量
使用 `const` 修饰普通变量可以让其值在初始化之后不再改变。

### 2.2 修饰指针
在指针的声明中，const 的位置决定了其作用对象。常见形式有三种：
1. **指向常量的指针**
   + 语法示例：
   ````c++
   const int* p1 = &maxCount; // 或者 int const* p1 = &maxCount;
   ````
   + 含义：指针所指向的内容不可改变，但指针本身可以指向其它地址（可变）。

2. **常量指针**
    + 语法示例：
    ````c++
    int* const p2 = &a;
    ````
    + 含义：指针本身不可修改，但是指针所指向的数据可变。

3. **指针和其指向的内容都为常量**
    + 语法示例：
    ````c++
    const int* const p3 = &maxCount;
    ````
    + 含义：既不能改变p3指向的地址，也不能改变p3所指向的内容。
  
**我们可以通过 `const` 的位置来判断。`const` 在 `*` 的左边，那么常量修饰的是指针所指向的内容； `const` 在 `*` 的右边，则常量修饰的是指针本身。

### 2.3 修饰引用
引用本身一旦绑定之后，是不允许被修改的。所以 `const` 是来限制在引用指向的数据不被修改。  
常用于通过 `const` 引用 来限制在函数参数中对原始数据的修改。
````c++
void printValue(const vector<int>& nums) {
    // nums[1] = 10; // 错误：无法修改传入的值
}
````

## 3. `const` 在函数中的应用
### 3.1 修饰形参
这样可以防止在函数内部对参数进行修改。
````c++
void processData(const int* data) {}
````

### 3.2 修饰返回值
如果函数返回的是**指针或引用**，加上 `const` 可以限制返回值不可被修改：
````c++
const std::string& getName() const {
    return name;
}
````
但是对于**值传递返回**（返回的是一个副本），加 `const` 的意义较小，因为副本在赋值后独立于原对象。

### 3.3 修饰成员函数
在类中，可以在成员函数后加上 `const`，这表示成员函数保证不修改对象（即不改变其非 `mutable` 成员）。
+ **注意**：对于 **`const` 对象**，只能调用 `const` 成员函数；如果调用非 `const` 的成员函数，编译器会报错。

## 4. `const` 对象与常量成员变量
### 4.1 常量对象
用 `const` 修饰的对象称为常量对象，创建后其所有数据均不可被修改，只能调用 `const` 成员函数。

### 4.2 成员变量的 `const` 限定
在类中，用 `const` 修饰的成员变量必须在构造函数的初始化阶段初始化。

## 5. 顶层 `const` 和底层 `const`
在 C++ 中，`const` 可以分为两种：
+ 顶层 `const`
  + 定义：直接修饰变量本身
    ````c++
    const int a = 10;
    ````
  + 在赋值与复制时，顶层 `const` 常常会**被忽略**（例如将 const int 赋值给 int）。
+ 底层 `const`
  + 定义：用于修饰指针或引用所指向的内容
    ````c++
    const int* p;
    ````
  + 在进行赋值转换时，**底层 `const` 的属性必须保持一致**

## 6. `const` 和 `constexpr`
`constexpr` 不仅表示变量或函数返回值为常量，还要求在编译期就能确定。  
`const` 和 `constexpr` 的区别在于：  
+ `const` 只保证变量**在运行期间不被修改**，但它的初始化表达式可能不是编译期常量。
+ `constexpr` 表示变量或函数在编译期就能计算出结果，适用于需要编译期常量（如数组大小、模板参数等）的场景。
    ````c++
    constexpr int getFive() { return 5; }
    int arr[getFive() + 3];  // 编译期确定长度
    ````

## 7. 使用建议
+ 尽可能使用 `const` 来**限定不希望修改的数据**。这有助于提升代码的可读性和安全性。
+ 对于函数参数，若**仅用作“输入”且不修改**，使用 `const` 引用或 `const` 指针。
+ 在类中，所有不需要修改对象状态的成员函数都应声明为 `const`，这不仅能防止错误修改，还能使得 `const` 对象能安全调用这些函数。
+ 在设计接口时，明确区分顶层 `const` 和底层 `const`，以防止不必要的隐式转换。
+ 在需要编译期常量的场合，优先考虑使用 `constexpr`，而不是简单的 `const`。

## 8. 小结
正确使用 `const` 不仅可以增强程序健壮性，还能提高编译器优化的可能性，减少运行时错误。在实际开发中，推荐广泛应用 `const`，以养成 `const-correct` 编程习惯，从而使代码更易于理解、维护和扩展。